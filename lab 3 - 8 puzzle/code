import heapq

# Goal state (blank = "-")
goal_state = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, "-"]]   # dash instead of 0

# Directions: up, down, left, right
moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# Convert board to tuple (for hashing in sets/dicts)
def board_to_tuple(board):
    return tuple(tuple(row) for row in board)

# Find position of a tile
def find_tile(board, value):
    for r in range(3):
        for c in range(3):
            if board[r][c] == value:
                return r, c

# Heuristic 1: Misplaced Tiles
def misplaced_tiles(board):
    count = 0
    for r in range(3):
        for c in range(3):
            if board[r][c] != "-" and board[r][c] != goal_state[r][c]:
                count += 1
    return count

# Heuristic 2: Manhattan Distance
def manhattan_distance(board):
    dist = 0
    for r in range(3):
        for c in range(3):
            val = board[r][c]
            if val != "-":
                goal_r, goal_c = divmod(val - 1, 3)
                dist += abs(r - goal_r) + abs(c - goal_c)
    return dist

# Generate neighbors
def get_neighbors(board):
    r, c = find_tile(board, "-")
    neighbors = []
    for dr, dc in moves:
        nr, nc = r + dr, c + dc
        if 0 <= nr < 3 and 0 <= nc < 3:
            new_board = [row[:] for row in board]
            new_board[r][c], new_board[nr][nc] = new_board[nr][nc], new_board[r][c]
            neighbors.append(new_board)
    return neighbors

# A* Search
def a_star(start, heuristic_func):
    open_list = []
    g_cost = {board_to_tuple(start): 0}
    heapq.heappush(open_list, (heuristic_func(start), start))
    came_from = {}

    while open_list:
        _, current = heapq.heappop(open_list)
        if current == goal_state:
            path = []
            while board_to_tuple(current) in came_from:
                path.append(current)
                current = came_from[board_to_tuple(current)]
            path.append(start)
            return path[::-1]

        for neighbor in get_neighbors(current):
            new_g = g_cost[board_to_tuple(current)] + 1
            neighbor_tuple = board_to_tuple(neighbor)
            if neighbor_tuple not in g_cost or new_g < g_cost[neighbor_tuple]:
                g_cost[neighbor_tuple] = new_g
                f_cost = new_g + heuristic_func(neighbor)
                heapq.heappush(open_list, (f_cost, neighbor))
                came_from[neighbor_tuple] = current

    return None

# Pretty print board
def print_board(board):
    for row in board:
        print(" ".join(str(x) for x in row))
    print()

if __name__ == "__main__":
    start_state = [[1, 2, 3],
                   [4, "-", 6],
                   [7, 5, 8]]

    print("Start State:")
    print_board(start_state)

    print("Solving with Misplaced Tiles Heuristic...")
    path1 = a_star(start_state, misplaced_tiles)
    if path1:
        for step in path1:
            print_board(step)

    print("Solving with Manhattan Distance Heuristic...")
    path2 = a_star(start_state, manhattan_distance)
    if path2:
        for step in path2:
            print_board(step)
